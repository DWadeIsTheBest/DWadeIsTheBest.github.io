<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter：platform channel]]></title>
    <url>%2F2019%2F05%2F18%2FFlutter%EF%BC%9Aplatform%20channel%2F</url>
    <content type="text"><![CDATA[Flutter使用了一个灵活的系统，允许您调用特定平台的API，无论在Android上的Java或Kotlin代码中，还是iOS上的ObjectiveC或Swift代码中均可用。 参考文献：Writing custom platform-specific code Flutter与原生之间的通信依赖灵活的消息传递方式： 应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）应用（原生应用）。 宿主监听平台通道，并接收该消息。然后它会调用该平台的API，并将响应发送回客户端，即应用程序的Flutter部分。 平台通道使用平台通道在Flutter(client)和原生(host)之间传递消息，如下图所示： 当在Flutter中调用原生方法时，调用信息通过平台通道传递到原生，原生收到调用信息后方可执行指定的操作，如需返回数据，则原生会将数据再通过平台通道传递给Flutter。值得注意的是消息传递是异步的，这确保了用户界面在消息传递时不会被挂起。 在客户端，MethodChannel API 可以发送与方法调用相对应的消息。 在宿主平台上，MethodChannel 在Android API 和 FlutterMethodChannel在 iOS API可以接收方法调用并返回结果。这些类可以帮助我们用很少的代码就能开发平台插件。 注意: 如果需要，方法调用(消息传递)可以是反向的，即宿主作为客户端调用Dart中实现的API。 quick_actions插件就是一个具体的例子。 创建一个新的应用程序项目首先创建一个新的应用程序: 在终端中运行：flutter create systemversion默认情况下，模板支持使用Java编写Android代码，或使用Objective-C编写iOS代码。要使用Kotlin或Swift，请使用-i和/或-a标志: 在终端中运行: flutter create -i swift -a kotlin systemversion Flutter端代码首先，我们构建通道。我们使用MethodChannel调用一个方法来返回系统版本。 通道的客户端和宿主通过通道构造函数中传递的通道名称进行连接。单个应用中使用的所有通道名称必须是唯一的; 我们建议在通道名称前加一个唯一的“域名前缀”，例如samples.flutter.io/systemVersion。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import &apos;dart:async&apos;;import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter/services.dart&apos;;void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget &#123; // This widget is the root of your application. @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return MyAppState(); &#125;&#125;class MyAppState extends State&lt;MyApp&gt; &#123;static const platform = const MethodChannel(&apos;samples.flutter.io/systemVersion&apos;); // Get battery level. String _systemVersion = &apos;Unknown system version.&apos;;// 我们调用通道上的方法，指定通过字符串标识符调用方法getSystemVersion。 // 该调用可能失败(平台不支持平台API，例如在模拟器中运行时)，// 所以我们将invokeMethod调用包装在try-catch语句中 Future&lt;Null&gt; _getSystemVersion() async &#123; String systemVersion; try &#123; final String result = await platform.invokeMethod(&apos;systemVersion&apos;); systemVersion = &apos;iOS当前系统 $result.&apos;; &#125; on PlatformException catch (e) &#123; systemVersion = &quot;Failed to get system version: &apos;$&#123;e.message&#125;&apos;.&quot;; &#125; // 在setState中来更新用户界面状态systemVersion setState(() &#123; _systemVersion = systemVersion; &#125;); &#125;// 我们在build创建包含一个小字体显示当前系统systemVersion// 和一个用于刷新值的按钮的用户界面。 @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo&apos;, theme: ThemeData( primarySwatch: Colors.blue, ), home: Scaffold( appBar: AppBar(title: Text(&quot;platform channel：与原生交互&quot;),), body: Center( child: new Column( children: &lt;Widget&gt;[ RaisedButton( onPressed: ()&#123;_getSystemVersion();&#125;, child: Text(&apos;show current systemVersion&apos;), ), Text(_systemVersion), ], ) ), ) ); &#125;&#125; iOS端代码我们接着之前”获取当前系统版本”插件的示例，来完成iOS端API的实现。以下步骤使用Objective-C 首先打开Xcode中Flutter应用程序的iOS部分: 启动 Xcode 选择 File &gt; Open… 定位到您 Flutter app目录, 然后选择里面的 iOS文件夹，点击 OK 确保Xcode项目的构建没有错误。 选择 Runner &gt; Runner ，打开AppDelegate.m 接下来，在application didFinishLaunchingWithOptions:方法内部创建一个FlutterMethodChannel，并添加一个处理方法。 确保与在Flutter客户端使用的通道名称相同。 1234567891011121314151617181920212223242526272829303132// ---------- AppDelegate.m ----------#include &quot;AppDelegate.h&quot;#include &quot;GeneratedPluginRegistrant.h&quot;@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [GeneratedPluginRegistrant registerWithRegistry:self]; FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* systemVersionChannel = [FlutterMethodChannel methodChannelWithName:@&quot;samples.flutter.io/systemVersion&quot; binaryMessenger:controller]; [systemVersionChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123; if ([@&quot;systemVersion&quot; isEqualToString:call.method]) &#123; result([self getSystemVersion]); // 回调数据 &#125; else &#123; result(FlutterMethodNotImplemented); &#125; &#125;]; // Override point for customization after application launch. return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;- (NSString *)getSystemVersion &#123; UIDevice* device = UIDevice.currentDevice; NSLog(@&quot;systemVersion==%@&quot;, device.systemVersion); return device.systemVersion;&#125;@end 效果如下：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳转界面时组件动画效果]]></title>
    <url>%2F2019%2F05%2F16%2F%E8%B7%B3%E8%BD%AC%E7%95%8C%E9%9D%A2%E6%97%B6%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言：有两个界面，如果在这两条路由上都有一个共同的视觉特性，那么在路由转换期间，将该特性物理地从一个页面移动到另一个页面，将有助于为用户确定该特性的方向。这样的动画叫做Hero动画。在过渡期间，Hero小部件在导航器的覆盖层中“飞翔”，当它们在飞行时，默认情况下，它们不会显示在新旧路线的原始位置。 要将小部件标记为这样的特性，请将其封装在Hero小部件中。当导航发生时，每个路由上的Hero小部件由HeroController标识。对于具有相同标记的每一对Hero小部件，都会触发一个Hero动画。比如说，在首页有一张图，显示在顶部，第二个界面也有相同的图，展示在界面中间，从首页到第二页添加Hero后会有动画，表现形式如下： 1、创建展示相同图片的两个界面12345678910111213141516171819202122232425262728293031323334353637// 当用户点击图像时，我们想要将图像从第一个界面到第二个界面有动画效果。class MainPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar(title: Text('主页'),), body: GestureDetector( onTap: ()&#123; Navigator.push(context, MaterialPageRoute( builder: (context) &#123; &#125; )); &#125;, child: Image.network('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg'), ), ); &#125;&#125;class DetailScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( onTap: () &#123; Navigator.pop(context); &#125;, child: Center( child: Image.network( 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg', ), ), ), ); &#125;&#125; 2、为首页添加hero组件// 为了让两个界面用动画连接在一起，需要在两个界面的图像中用 Hero 包装，// Hero 组件需要两个参数 // 1、tag：hero 的标识，它必须跟所有界面相同// 2、child: 我们希望跨屏幕动画的小部件123456Hero( tag: 'imageHero', child: Image.network( 'https://', ),); 3、为第二页添加hero组件123456Hero( tag: &apos;imageHero&apos;, child: Image.network( &apos;https://&apos;, ),); 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import 'package:flutter/material.dart';void main() &#123; runApp(MaterialApp( title: '过渡Demo', home: MainPage(), ));&#125;// 1、Create two screens showing the same image// 当用户点击图像时，我们想要将图像从第一个界面到第二个界面有动画效果。class MainPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar(title: Text('主页'),), body: GestureDetector( onTap: ()&#123; Navigator.push(context, MaterialPageRoute( builder: (context) &#123; return DetailScreen(); &#125; )); &#125;, child: Hero( tag: 'imageHero1', child: Image.network('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg'), ) ), ); &#125;&#125;class DetailScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( onTap: () &#123; Navigator.pop(context); &#125;, child: Center( child: Hero( tag: 'imageHero1', child: Image.network( 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg', ), ) ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名路由跳转]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[前言：我们学习了如何通过创建新路由并将其推到导航器来导航到新界面。然而，如果我们需要在项目的许多多方导航到相同的屏幕，这会导致代码重复。在这些情况下，可以方便地定义一个“命名路由”，并使用命名路由进行导航。 1. 创建两个界面12345678910111213141516171819202122232425262728293031323334// 首先我们创建两个界面，第一个界面包含跳转到第二个界面的按钮，第二个界面包含返回到首页的按钮class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('首页'),), body: Center( child: RaisedButton( child: Text("跳转界面"), onPressed: () &#123; Navigator.pushNamed(context, '/second'); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('第二个界面'),), body: Center( child: RaisedButton( child: Text("返回"), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 2. 定义路由12345678MaterialApp( initialRoute: '/', routes: &#123; //以“/”命名路由启动应用程序。在本例子中，应用程序将跳转到首页上 '/': (context) =&gt; FirstScreen(), '/second': (context) =&gt; SecondScreen(), &#125;,); 3. 导航跳转到第二页123onPressed: () &#123; Navigator.pushNamed(context, '/second');&#125; 4. 返回首页123onPressed: () &#123; Navigator.pop(context);&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';void main() &#123; runApp(MaterialApp( initialRoute: '/', routes: &#123; //以“/”命名路由启动应用程序。在本例子中，应用程序将跳转到首页上 '/':(context) =&gt; FirstPage(), '/second': (context) =&gt; SecondPage(), &#125;,));&#125;// 1. Create two screens// 首先我们创建两个界面，第一个界面包含跳转到第二个界面的按钮，第二个界面包含返回到首页的按钮class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('首页'),), body: Center( child: RaisedButton( child: Text("跳转界面"), onPressed: () &#123; Navigator.pushNamed(context, '/second'); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('第二个界面'),), body: Center( child: RaisedButton( child: Text("返回首页"), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面跳转返回数据]]></title>
    <url>%2F2019%2F05%2F16%2F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言：有时候，我们想从新界面返回数据。比如，我们从首页到第二页，然后第二页有两个选项给用户选择，用户选择后，返回首页，并且返回用户的选项。这个就需要用到Navigator.pop 1.创建首页 Home Page123456789101112class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar(title: Text(&apos;返回数据Demo&apos;),), body: Center( // 创造一个按钮 child: SelectionButton(), ), ); &#125;&#125; 2. 添加一个按钮跳转到选择界面12345678910111213141516171819202122// 点击时弹出选择界面// 等到返回结果class SelectionButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( onPressed: () &#123; //点击跳转到选择界面 _navigationAndDisplaySelection(context); &#125;, child: Text(&apos;随便选择一个选项&apos;), ); &#125; _navigationAndDisplaySelection(BuildContext context) async &#123; final result = await Navigator.push( context, // 下面我们创建选择界面 MaterialPageRoute(builder: (context) =&gt; SelectionPage()) ); &#125;&#125; 3、显示带两个选择按钮的选择界面123456789101112131415161718192021222324252627282930313233343536class SelectionPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&apos;选择一个&apos;), ), body: Center( //垂直布局 child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; &#125;, child: Text(&apos;勇士&apos;), ), ), Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; &#125;, child: Text(&apos;火箭&apos;), ), ) ], ), ), ); &#125;&#125; 4. 点击选择按钮，关闭当前界面123456789Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; Navigator.pop(context, &apos;火箭&apos;); &#125;, child: Text(&apos;火箭&apos;), ),) 5. 点击选择按钮，回到首页，并显示消息控件snackbar12345678910111213141516171819_navigationAndDisplaySelection(BuildContext context) async &#123; final result = await Navigator.push( context, // 下面我们创建选择界面 MaterialPageRoute(builder: (context) =&gt; SelectionPage()) ); //选择屏幕返回结果后，隐藏之前的任何snackbar，并显示新的结果! Scaffold.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content:Text(&apos;$result&apos;), duration: Duration(seconds: 5))); // snackbar 是一个轻量级的消息显示控件，可以在屏幕底部短暂的显示 // 要显示一个nackBar，调用Scaffold.of(context). showsnackbar()， // 传递一个描述消息的SnackBar实例。 // 也可以控制显示的时间,默认是4s &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp(MaterialApp( title: &apos;返回数据&apos;, home: HomePage(), ));&#125;// 1. Define the home screenclass HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar(title: Text(&apos;返回数据Demo&apos;),), body: Center( // 创造选择按钮 child: SelectionButton(), ), ); &#125;&#125;// 2. Add a button that launches the selection screen// 点击时弹出选择界面// 等到返回结果class SelectionButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( onPressed: () &#123; //点击跳转到选择界面 _navigationAndDisplaySelection(context); &#125;, child: Text(&apos;随便选择一个选项&apos;), ); &#125; _navigationAndDisplaySelection(BuildContext context) async &#123; final result = await Navigator.push( context, // 下面我们创建选择界面 MaterialPageRoute(builder: (context) =&gt; SelectionPage()) ); //选择屏幕返回结果后，隐藏之前的任何snackbar，并显示新的结果! Scaffold.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content:Text(&apos;$result&apos;), duration: Duration(seconds: 5))); // snackbar 是一个轻量级的消息显示控件，可以在屏幕底部短暂的显示 // 要显示一个nackBar，调用Scaffold.of(context). showsnackbar()， // 传递一个描述消息的SnackBar实例。 // 也可以控制显示的时间,默认是4s &#125;&#125;// 3. Show the selection screen with two buttonsclass SelectionPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&apos;选择一个&apos;), ), body: Center( //垂直布局 child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; // Navigator.pop 可接受第二个参数，第二个参数是可选的，可以不传 Navigator.pop(context, &apos;勇士&apos;); &#125;, child: Text(&apos;勇士&apos;), ), ), Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; Navigator.pop(context, &apos;火箭&apos;); &#125;, child: Text(&apos;火箭&apos;), ), ) ], ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python爬取电影天堂]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E7%88%AC%E5%8F%96%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82%2F</url>
    <content type="text"><![CDATA[前言： 本文非常浅显易懂，可以说是零基础也可快速掌握。如有疑问，欢迎留言，笔者会第一时间回复。本文代码存于github 一、爬虫的重要性： 如果把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。网络蜘蛛通过网页的链接地址来寻找网页，从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，一直循环下去，直到把整个网站所有的网页都抓取完为止。 摘取部分网友的回复：1、之前在北京买房，谁想房价开始疯长，链家的房价等数据分析只给了一小部分，远远不能满足自己的需求。于是晚上花了几个小时的时间写了个爬虫，爬下了北京所有的小区信息及北京所有小区的所有历史成交记录。 2、我的爱人是某网络公司的销售，需要收集各种企业信息然后打电话联系。于是乎利用采集脚本抓一坨一坨的资料给她用，而她的同事天天自己搜资料整理到半夜。 二、实践：爬取电影天堂电影详情页1、网页分析及爬取第一页的详情页url从电影天堂最新电影界面。可以看到其第一页url为 http://www.ygdy8.net/html/gndy/dyzz/list_23_1.html第二页为http://www.ygdy8.net/html/gndy/dyzz/list_23_2.html，第三第四页也类似 12345678910111213141516from lxml import etreeimport requestsurl = &apos;http://www.ygdy8.net/html/gndy/dyzz/list_23_1.html&apos;headers = &#123; &apos;User_Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;,&#125;response = requests.get(url,headers=headers)# response.text 是系统自己默认判断。但很遗憾判断错误，导致乱码出现。我们可以采取另外方式 response.content。自己指定格式解码# print(response.text)# print(response.content.decode(&apos;gbk&apos;))print(response.content.decode(encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;)) 先以第一页为例，打印数据如下： 分析电影天堂 html 源代码，可以得出每个 table 标签就是一个电影 通过 xpath 拿到每个电影的详情url1234html = etree.HTML(text)detail_urls = html.xpath(&quot;//table[@class=&apos;tbspan&apos;]//a/@href&quot;)for detail_url in detail_urls: print(detail_url) #加上域名即为详情 url 结果如下： 2、整理代码并爬取前7页的电影列表url12345678910111213141516171819from lxml import etreeimport requests# 域名BASE_DOMAIN = &apos;http://www.ygdy8.net&apos;# url = &apos;http://www.ygdy8.net/html/gndy/dyzz/list_23_1.html&apos;HEADERS = &#123; &apos;User_Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;,&#125;def spider(): base_url = &apos;http://www.ygdy8.net/html/gndy/dyzz/list_23_&#123;&#125;.html&apos; for x in range(1,8): url = base_url.format(x) print(url) # 求出每一页电影列表的url eg: http://www.ygdy8.net/html/gndy/dyzz/list_23_1.htmlif __name__ == &apos;__main__&apos;: spider() 3、爬取每一部电影的详情页地址1234567891011121314151617181920212223def get_detail_urls(url): response = requests.get(url, headers=HEADERS) # response.text 是系统自己默认判断。但很遗憾判断错误，导致乱码出现。我们可以采取另外方式 response.content。自己指定格式解码 # print(response.text) # print(response.content.decode(&apos;gbk&apos;)) # print(response.content.decode(encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;)) text = response.content.decode(encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;) # 通过 xpath 拿到每个电影的详情url html = etree.HTML(text) detail_urls = html.xpath(&quot;//table[@class=&apos;tbspan&apos;]//a/@href&quot;) detail_urls = map(lambda url:BASE_DOMAIN+url,detail_urls) #这句意思相当于下面一段代码:替换列表中的每一个url # def abc(url): # return BASE_DOMAIN+url # index = 1 # for detail_url in detail_urls: # detail_url = abc(detail_url) # detail_urls[index] = detail_url # index+1 return detail_urls 4、抓取电影详情页的数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 解析详情页面def parse_detail_page(url): movie = &#123;&#125; response = requests.get(url,headers = HEADERS) text = response.content.decode(&apos;gbk&apos;, errors=&apos;ignore&apos;) html = etree.HTML(text) # title = html.xpath(&quot;//div[@class=&apos;title_all&apos;]//font[@color=&apos;#07519a&apos;]&quot;) # 本行47行，下面已修改 # 打印出 [&lt;Element font at 0x10cb422c8&gt;, &lt;Element font at 0x10cb42308&gt;] # print(title) # 为了显示，我们需要转一下编码 # for x in title: # print(etree.tostring(x,encoding=&apos;utf-8&apos;).decode(&apos;utf-8&apos;)) # 我们是为了取得文字，所以修改47行 title = html.xpath(&quot;//div[@class=&apos;title_all&apos;]//font[@color=&apos;#07519a&apos;]/text()&quot;)[0] movie[&apos;title&apos;] = title zoomE = html.xpath(&quot;//div[@id=&apos;Zoom&apos;]&quot;) [0] # 求出共同的顶级容器，方便后面求职 imgs = zoomE.xpath(&quot;.//img/@src&quot;) # 求出海报和截图 cover = imgs[0] if len(imgs) &gt; 1: screenshot = imgs[1] movie[&apos;screenshot&apos;] = screenshot # print(cover) movie[&apos;cover&apos;] = cover infos = zoomE.xpath(&quot;.//text()&quot;) for index,info in enumerate(infos): if info.startswith(&apos;◎年 代&apos;): info = info.replace(&quot;◎年 代&quot;, &quot;&quot;).strip() # strip 去掉空格 movie[&apos;year&apos;] = info elif info.startswith(&quot;◎产 地&quot;): info = info.replace(&quot;◎产 地&quot;, &quot;&quot;).strip() movie[&quot;country&quot;] = info elif info.startswith(&quot;◎类 别&quot;): info = info.replace(&quot;◎类 别&quot;, &quot;&quot;).strip() movie[&quot;category&quot;] = info elif info.startswith(&quot;◎豆瓣评分&quot;): info = info.replace(&quot;◎豆瓣评分&quot;, &quot;&quot;).strip() movie[&quot;douban_rating&quot;] = info elif info.startswith(&quot;◎片 长&quot;): info = info.replace(&quot;◎片 长&quot;,&quot;&quot;).strip() movie[&quot;duration&quot;] = info elif info.startswith(&quot;◎导 演&quot;): info = info.replace(&quot;◎导 演&quot;, &quot;&quot;).strip() movie[&quot;director&quot;] = info elif info.startswith(&quot;◎主 演&quot;): actors = [] actor = info.replace(&quot;◎主 演&quot;, &quot;&quot;).strip() actors.append(actor) # 因为主演有很多个，再加上其在电影天堂中元素的特殊性，需要遍历一遍，在分别求出每一个演员 for x in range(index+1,len(infos)): # 从演员 infos 开始遍历，求出每一个演员 actor = infos[x].strip() if actor.startswith(&quot;◎&quot;): # 也就是到了标签 的 ◎ 就退出 break actors.append(actor) movie[&apos;actor&apos;] = actors elif info.startswith(&apos;◎简 介 &apos;): # info = info.replace(&apos;◎简 介 &apos;,&quot;&quot;).strip() for x in range(index+1,len(infos)): if infos[x].startswith(&quot;◎获奖情况&quot;): break profile = infos[x].strip() movie[&apos;profile&apos;] = profile # print(movie) elif info.startswith(&apos;◎获奖情况 &apos;): awards = [] # info = info.replace(&quot;◎获奖情况 &quot;, &quot;&quot;).strip() for x in range(index+1,len(infos)): if infos[x].startswith(&quot;【下载地址】&quot;): break award = infos[x].strip() awards.append(award) movie[&apos;awards&apos;] = awards # print(awards) download_url = html.xpath(&quot;//td[@bgcolor=&apos;#fdfddf&apos;]/a/@href&quot;)[0] movie[&apos;download_url&apos;] = download_url return movie 上述代码爬取了电影的每一个数据。为了让读者方便对照格式，笔者已经下载了写此篇文章时的html—— “movie.html”，放于github 中 最后结果：]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
</search>
