<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[平台通道platform channel]]></title>
    <url>%2F2019%2F05%2F18%2Fplatformchannel%2F</url>
    <content type="text"><![CDATA[Flutter使用了一个灵活的系统，允许您调用特定平台的API，无论在Android上的Java或Kotlin代码中，还是iOS上的ObjectiveC或Swift代码中均可用。 参考文献：Writing custom platform-specific code Flutter与原生之间的通信依赖灵活的消息传递方式： 应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）应用（原生应用）。 宿主监听平台通道，并接收该消息。然后它会调用该平台的API，并将响应发送回客户端，即应用程序的Flutter部分。 平台通道使用平台通道在Flutter(client)和原生(host)之间传递消息，如下图所示： 当在Flutter中调用原生方法时，调用信息通过平台通道传递到原生，原生收到调用信息后方可执行指定的操作，如需返回数据，则原生会将数据再通过平台通道传递给Flutter。值得注意的是消息传递是异步的，这确保了用户界面在消息传递时不会被挂起。 在客户端，MethodChannel API 可以发送与方法调用相对应的消息。 在宿主平台上，MethodChannel 在Android API 和 FlutterMethodChannel在 iOS API可以接收方法调用并返回结果。这些类可以帮助我们用很少的代码就能开发平台插件。 注意: 如果需要，方法调用(消息传递)可以是反向的，即宿主作为客户端调用Dart中实现的API。 quick_actions插件就是一个具体的例子。 创建一个新的应用程序项目首先创建一个新的应用程序: 在终端中运行：flutter create systemversion默认情况下，模板支持使用Java编写Android代码，或使用Objective-C编写iOS代码。要使用Kotlin或Swift，请使用-i和/或-a标志: 在终端中运行: flutter create -i swift -a kotlin systemversion Flutter端代码首先，我们构建通道。我们使用MethodChannel调用一个方法来返回系统版本。 通道的客户端和宿主通过通道构造函数中传递的通道名称进行连接。单个应用中使用的所有通道名称必须是唯一的; 我们建议在通道名称前加一个唯一的“域名前缀”，例如samples.flutter.io/systemVersion。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import &apos;dart:async&apos;;import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter/services.dart&apos;;void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget &#123; // This widget is the root of your application. @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return MyAppState(); &#125;&#125;class MyAppState extends State&lt;MyApp&gt; &#123;static const platform = const MethodChannel(&apos;samples.flutter.io/systemVersion&apos;); // Get battery level. String _systemVersion = &apos;Unknown system version.&apos;;// 我们调用通道上的方法，指定通过字符串标识符调用方法getSystemVersion。 // 该调用可能失败(平台不支持平台API，例如在模拟器中运行时)，// 所以我们将invokeMethod调用包装在try-catch语句中 Future&lt;Null&gt; _getSystemVersion() async &#123; String systemVersion; try &#123; final String result = await platform.invokeMethod(&apos;systemVersion&apos;); systemVersion = &apos;iOS当前系统 $result.&apos;; &#125; on PlatformException catch (e) &#123; systemVersion = &quot;Failed to get system version: &apos;$&#123;e.message&#125;&apos;.&quot;; &#125; // 在setState中来更新用户界面状态systemVersion setState(() &#123; _systemVersion = systemVersion; &#125;); &#125;// 我们在build创建包含一个小字体显示当前系统systemVersion// 和一个用于刷新值的按钮的用户界面。 @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo&apos;, theme: ThemeData( primarySwatch: Colors.blue, ), home: Scaffold( appBar: AppBar(title: Text(&quot;platform channel：与原生交互&quot;),), body: Center( child: new Column( children: &lt;Widget&gt;[ RaisedButton( onPressed: ()&#123;_getSystemVersion();&#125;, child: Text(&apos;show current systemVersion&apos;), ), Text(_systemVersion), ], ) ), ) ); &#125;&#125; iOS端代码我们接着之前”获取当前系统版本”插件的示例，来完成iOS端API的实现。以下步骤使用Objective-C 首先打开Xcode中Flutter应用程序的iOS部分: 启动 Xcode 选择 File &gt; Open… 定位到您 Flutter app目录, 然后选择里面的 iOS文件夹，点击 OK 确保Xcode项目的构建没有错误。 选择 Runner &gt; Runner ，打开AppDelegate.m 接下来，在application didFinishLaunchingWithOptions:方法内部创建一个FlutterMethodChannel，并添加一个处理方法。 确保与在Flutter客户端使用的通道名称相同。 1234567891011121314151617181920212223242526272829303132// ---------- AppDelegate.m ----------#include &quot;AppDelegate.h&quot;#include &quot;GeneratedPluginRegistrant.h&quot;@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [GeneratedPluginRegistrant registerWithRegistry:self]; FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* systemVersionChannel = [FlutterMethodChannel methodChannelWithName:@&quot;samples.flutter.io/systemVersion&quot; binaryMessenger:controller]; [systemVersionChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123; if ([@&quot;systemVersion&quot; isEqualToString:call.method]) &#123; result([self getSystemVersion]); // 回调数据 &#125; else &#123; result(FlutterMethodNotImplemented); &#125; &#125;]; // Override point for customization after application launch. return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;- (NSString *)getSystemVersion &#123; UIDevice* device = UIDevice.currentDevice; NSLog(@&quot;systemVersion==%@&quot;, device.systemVersion); return device.systemVersion;&#125;@end 效果如下：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳转界面时组件动画效果]]></title>
    <url>%2F2019%2F05%2F16%2F%E8%B7%B3%E8%BD%AC%E7%95%8C%E9%9D%A2%E6%97%B6%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言：有两个界面，如果在这两条路由上都有一个共同的视觉特性，那么在路由转换期间，将该特性物理地从一个页面移动到另一个页面，将有助于为用户确定该特性的方向。这样的动画叫做Hero动画。在过渡期间，Hero小部件在导航器的覆盖层中“飞翔”，当它们在飞行时，默认情况下，它们不会显示在新旧路线的原始位置。 要将小部件标记为这样的特性，请将其封装在Hero小部件中。当导航发生时，每个路由上的Hero小部件由HeroController标识。对于具有相同标记的每一对Hero小部件，都会触发一个Hero动画。比如说，在首页有一张图，显示在顶部，第二个界面也有相同的图，展示在界面中间，从首页到第二页添加Hero后会有动画，表现形式如下： 1、创建展示相同图片的两个界面12345678910111213141516171819202122232425262728293031323334353637// 当用户点击图像时，我们想要将图像从第一个界面到第二个界面有动画效果。class MainPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar(title: Text('主页'),), body: GestureDetector( onTap: ()&#123; Navigator.push(context, MaterialPageRoute( builder: (context) &#123; &#125; )); &#125;, child: Image.network('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg'), ), ); &#125;&#125;class DetailScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( onTap: () &#123; Navigator.pop(context); &#125;, child: Center( child: Image.network( 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg', ), ), ), ); &#125;&#125; 2、为首页添加hero组件// 为了让两个界面用动画连接在一起，需要在两个界面的图像中用 Hero 包装，// Hero 组件需要两个参数 // 1、tag：hero 的标识，它必须跟所有界面相同// 2、child: 我们希望跨屏幕动画的小部件123456Hero( tag: 'imageHero', child: Image.network( 'https://', ),); 3、为第二页添加hero组件123456Hero( tag: &apos;imageHero&apos;, child: Image.network( &apos;https://&apos;, ),); 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import 'package:flutter/material.dart';void main() &#123; runApp(MaterialApp( title: '过渡Demo', home: MainPage(), ));&#125;// 1、Create two screens showing the same image// 当用户点击图像时，我们想要将图像从第一个界面到第二个界面有动画效果。class MainPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar(title: Text('主页'),), body: GestureDetector( onTap: ()&#123; Navigator.push(context, MaterialPageRoute( builder: (context) &#123; return DetailScreen(); &#125; )); &#125;, child: Hero( tag: 'imageHero1', child: Image.network('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg'), ) ), ); &#125;&#125;class DetailScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( onTap: () &#123; Navigator.pop(context); &#125;, child: Center( child: Hero( tag: 'imageHero1', child: Image.network( 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558288400704&amp;di=d136bc8e492fb1a93953405ee183103f&amp;imgtype=0&amp;src=http%3A%2F%2Fp1.ishecdn.com%2Fc%2F12538544_0_0_2_80.jpg', ), ) ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名路由跳转]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[前言：我们学习了如何通过创建新路由并将其推到导航器来导航到新界面。然而，如果我们需要在项目的许多多方导航到相同的屏幕，这会导致代码重复。在这些情况下，可以方便地定义一个“命名路由”，并使用命名路由进行导航。 1. 创建两个界面12345678910111213141516171819202122232425262728293031323334// 首先我们创建两个界面，第一个界面包含跳转到第二个界面的按钮，第二个界面包含返回到首页的按钮class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('首页'),), body: Center( child: RaisedButton( child: Text("跳转界面"), onPressed: () &#123; Navigator.pushNamed(context, '/second'); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('第二个界面'),), body: Center( child: RaisedButton( child: Text("返回"), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 2. 定义路由12345678MaterialApp( initialRoute: '/', routes: &#123; //以“/”命名路由启动应用程序。在本例子中，应用程序将跳转到首页上 '/': (context) =&gt; FirstScreen(), '/second': (context) =&gt; SecondScreen(), &#125;,); 3. 导航跳转到第二页123onPressed: () &#123; Navigator.pushNamed(context, '/second');&#125; 4. 返回首页123onPressed: () &#123; Navigator.pop(context);&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';void main() &#123; runApp(MaterialApp( initialRoute: '/', routes: &#123; //以“/”命名路由启动应用程序。在本例子中，应用程序将跳转到首页上 '/':(context) =&gt; FirstPage(), '/second': (context) =&gt; SecondPage(), &#125;,));&#125;// 1. Create two screens// 首先我们创建两个界面，第一个界面包含跳转到第二个界面的按钮，第二个界面包含返回到首页的按钮class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('首页'),), body: Center( child: RaisedButton( child: Text("跳转界面"), onPressed: () &#123; Navigator.pushNamed(context, '/second'); &#125;, ), ), ); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: new Text('第二个界面'),), body: Center( child: RaisedButton( child: Text("返回首页"), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面跳转返回数据]]></title>
    <url>%2F2019%2F05%2F16%2F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言：有时候，我们想从新界面返回数据。比如，我们从首页到第二页，然后第二页有两个选项给用户选择，用户选择后，返回首页，并且返回用户的选项。这个就需要用到Navigator.pop 1.创建首页 Home Page123456789101112class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar(title: Text(&apos;返回数据Demo&apos;),), body: Center( // 创造一个按钮 child: SelectionButton(), ), ); &#125;&#125; 2. 添加一个按钮跳转到选择界面12345678910111213141516171819202122// 点击时弹出选择界面// 等到返回结果class SelectionButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( onPressed: () &#123; //点击跳转到选择界面 _navigationAndDisplaySelection(context); &#125;, child: Text(&apos;随便选择一个选项&apos;), ); &#125; _navigationAndDisplaySelection(BuildContext context) async &#123; final result = await Navigator.push( context, // 下面我们创建选择界面 MaterialPageRoute(builder: (context) =&gt; SelectionPage()) ); &#125;&#125; 3、显示带两个选择按钮的选择界面123456789101112131415161718192021222324252627282930313233343536class SelectionPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&apos;选择一个&apos;), ), body: Center( //垂直布局 child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; &#125;, child: Text(&apos;勇士&apos;), ), ), Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; &#125;, child: Text(&apos;火箭&apos;), ), ) ], ), ), ); &#125;&#125; 4. 点击选择按钮，关闭当前界面123456789Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; Navigator.pop(context, &apos;火箭&apos;); &#125;, child: Text(&apos;火箭&apos;), ),) 5. 点击选择按钮，回到首页，并显示消息控件snackbar12345678910111213141516171819_navigationAndDisplaySelection(BuildContext context) async &#123; final result = await Navigator.push( context, // 下面我们创建选择界面 MaterialPageRoute(builder: (context) =&gt; SelectionPage()) ); //选择屏幕返回结果后，隐藏之前的任何snackbar，并显示新的结果! Scaffold.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content:Text(&apos;$result&apos;), duration: Duration(seconds: 5))); // snackbar 是一个轻量级的消息显示控件，可以在屏幕底部短暂的显示 // 要显示一个nackBar，调用Scaffold.of(context). showsnackbar()， // 传递一个描述消息的SnackBar实例。 // 也可以控制显示的时间,默认是4s &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp(MaterialApp( title: &apos;返回数据&apos;, home: HomePage(), ));&#125;// 1. Define the home screenclass HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar(title: Text(&apos;返回数据Demo&apos;),), body: Center( // 创造选择按钮 child: SelectionButton(), ), ); &#125;&#125;// 2. Add a button that launches the selection screen// 点击时弹出选择界面// 等到返回结果class SelectionButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( onPressed: () &#123; //点击跳转到选择界面 _navigationAndDisplaySelection(context); &#125;, child: Text(&apos;随便选择一个选项&apos;), ); &#125; _navigationAndDisplaySelection(BuildContext context) async &#123; final result = await Navigator.push( context, // 下面我们创建选择界面 MaterialPageRoute(builder: (context) =&gt; SelectionPage()) ); //选择屏幕返回结果后，隐藏之前的任何snackbar，并显示新的结果! Scaffold.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content:Text(&apos;$result&apos;), duration: Duration(seconds: 5))); // snackbar 是一个轻量级的消息显示控件，可以在屏幕底部短暂的显示 // 要显示一个nackBar，调用Scaffold.of(context). showsnackbar()， // 传递一个描述消息的SnackBar实例。 // 也可以控制显示的时间,默认是4s &#125;&#125;// 3. Show the selection screen with two buttonsclass SelectionPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&apos;选择一个&apos;), ), body: Center( //垂直布局 child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; // Navigator.pop 可接受第二个参数，第二个参数是可选的，可以不传 Navigator.pop(context, &apos;勇士&apos;); &#125;, child: Text(&apos;勇士&apos;), ), ), Padding( padding: const EdgeInsets.all(8.0), child: RaisedButton( onPressed: ()&#123; Navigator.pop(context, &apos;火箭&apos;); &#125;, child: Text(&apos;火箭&apos;), ), ) ], ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter:使用shared_preferences]]></title>
    <url>%2F2019%2F04%2F25%2F%E4%BD%BF%E7%94%A8shared_preferences%2F</url>
    <content type="text"><![CDATA[Flutter包类似java中的jar包，iOS中的第三方框架，也是由全球众多开发者共同提供第三方库。巧用这些包资源，无须从头造轮子，提升效率。 [包仓库地址]https://pub.dev/ 今天我们使用一个存储库——shared_preferences 来讲解。 介绍shared_preferences仓库地址：https://pub.dev/packages/shared_preferences shared_preferences：包装NSUserDefaults(在iOS上)和SharedPreferences(在Android上)，为简单数据提供一个持久存储。数据异步地保存到磁盘。两个平台都不能保证写操作在返回后被持久化到磁盘上，而且这个插件不能用于存储关键数据。 使用在 pubspec.yaml 里添加： dependencies: shared_preferences: ^0.5.2 然后运行： flutter packages get 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import &apos;package:flutter/material.dart&apos;;import &apos;package:shared_preferences/shared_preferences.dart&apos;;void main() &#123; runApp(_CounterWidget());&#125;class _CounterWidget extends StatefulWidget &#123; @override _CounterState createState() =&gt; _CounterState();&#125;class _CounterState extends State&lt;_CounterWidget&gt; &#123; String countString = &apos;&apos;; String localCount = &apos;&apos;; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( appBar: new AppBar( title: Text(&apos;Flutter存储--shared_preferences&apos;), ), body: Container( child: Column( children: &lt;Widget&gt;[ RaisedButton( onPressed: _incrementCounter, child: Text(&apos;Increment Counter&apos;)), RaisedButton( onPressed: _getCounter, child: Text(&apos;Get Counter&apos;) ), RaisedButton( onPressed: _removeCounter, child: Text(&apos;remove Counter&apos;) ), Text( countString, style: TextStyle(fontSize: 20), ), Text( &apos;result：&apos; + localCount, style: TextStyle(fontSize: 20), ), ], ), ), ), ); &#125; // 注意这里读取数据是异步的，所以 _incrementCounter() 方法要加 async： _incrementCounter() async &#123; SharedPreferences prefs = await SharedPreferences.getInstance(); print(&apos;increment counter&apos;); setState(() &#123; countString = countString + &quot; 1&quot;; &#125;); // 尝试读取数据。如果不存在，返回0。 int counter = (prefs.getInt(&apos;counter&apos;) ?? 0) + 1; await prefs.setInt(&apos;counter&apos;, counter); &#125; _getCounter() async &#123; SharedPreferences prefs = await SharedPreferences.getInstance(); print(&apos;get counter&apos;); setState(() &#123; localCount = prefs.getInt(&apos;counter&apos;).toString(); if (localCount == &quot;null&quot;) &#123; localCount = &quot;0&quot;; &#125; &#125;); &#125; _removeCounter() async &#123; SharedPreferences prefs = await SharedPreferences.getInstance(); prefs.remove(&apos;counter&apos;).toString(); print(&apos;remove counter&apos;); setState(() &#123; localCount = &quot;0&quot;; &#125;); &#125;&#125; 效果如下：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter:TextField文本框]]></title>
    <url>%2F2019%2F04%2F24%2FTextField%E6%96%87%E6%9C%AC%E6%A1%86%2F</url>
    <content type="text"><![CDATA[简单的TextField下面是个简单的TextField例子123456789101112131415161718192021222324252627282930313233import &apos;package:flutter/material.dart&apos;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( appBar: new AppBar( title: new Text(&apos;textfield demo&apos;), ), body: TextField( decoration: InputDecoration( border: OutlineInputBorder(), labelText: &apos;账号&apos;, ), onChanged: (String data) &#123; print(&apos;$data&apos;); &#125;, onTap: ()&#123; print(&apos;tap。。。&apos;); &#125;, onSubmitted: (String data)&#123; print(&apos;提交的文字是$data&apos;); &#125;, ), ) ); &#125;&#125; 效果如下： TextField有4种提示： 1、helperText：在输入框底部 2、suffixText：在输入框后缀，不会当做输入的文字，仅做提示，但是会占用输入框的位置。 3、hintText：在输入框中间，输入文字后会消失 4、labelText: 当输入字段为空且未聚焦时，标签将显示在输入字段的顶部。聚焦后，标签会移动到输入框上面 监听输入的文字 1、TextField的直接属性，比第2种监听更简单 123onChanged: (String text)&#123; print(&apos;onChange:$text&apos;);&#125;, 2、TextField的controller属性，看出比第1种多一步 123controller.addListener(()&#123; print(&apos;你输入的内容为:$&#123;controller.text&#125;&apos;);&#125;); 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &apos;package:flutter/cupertino.dart&apos;;import &apos;package:flutter/material.dart&apos;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; final TextEditingController controller = TextEditingController(); controller.addListener(()&#123; print(&apos;你输入的内容为:$&#123;controller.text&#125;&apos;); &#125;); return MaterialApp( home: Scaffold( appBar: new AppBar( title: new Text(&apos;textfield demo&apos;), ), body: Center( child: Padding( padding: const EdgeInsets.all(20.0), child: TextField( controller: controller, maxLength: 20, //设置此项会让输入框右下角有个输入数量的统计字符串 maxLines: 1, autocorrect: true, autofocus: false, //设置为true,则会自定聚焦，不用点击输入框 obscureText: false, //是否密文 textAlign: TextAlign.center, style: TextStyle( fontSize: 26.0, color: Colors.green, ), enabled: true, //设置false不能点击，而且颜色会被渲染呈灰色 decoration: InputDecoration( fillColor: Colors.grey.shade200, //填充输入框 filled: true, //设置false，fillColor,就不起作用,默认为false prefixIcon: Icon( Icons.person, color:Colors.blue, //改变icon颜色 size: 30.0, ), //左侧图标 helperText: &apos;helperText用户名&apos;, suffixText: &apos;suffix&apos;, labelText: &apos;labelText&apos;, //当输入字段为空且未聚焦时，标签将显示在输入字段的顶部。聚焦后，标签会移动到输入框上面 hintText: &apos;hintText&apos; ), ), ), ), ) ); &#125;&#125; 效果如下：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取电影天堂]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E7%88%AC%E5%8F%96%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82%2F</url>
    <content type="text"><![CDATA[前言： 本文非常浅显易懂，可以说是零基础也可快速掌握。如有疑问，欢迎留言，笔者会第一时间回复。本文代码存于github 一、爬虫的重要性： 如果把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。网络蜘蛛通过网页的链接地址来寻找网页，从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，一直循环下去，直到把整个网站所有的网页都抓取完为止。 摘取部分网友的回复：1、之前在北京买房，谁想房价开始疯长，链家的房价等数据分析只给了一小部分，远远不能满足自己的需求。于是晚上花了几个小时的时间写了个爬虫，爬下了北京所有的小区信息及北京所有小区的所有历史成交记录。 2、我的爱人是某网络公司的销售，需要收集各种企业信息然后打电话联系。于是乎利用采集脚本抓一坨一坨的资料给她用，而她的同事天天自己搜资料整理到半夜。 二、实践：爬取电影天堂电影详情页1、网页分析及爬取第一页的详情页url从电影天堂最新电影界面。可以看到其第一页url为 http://www.ygdy8.net/html/gndy/dyzz/list_23_1.html第二页为http://www.ygdy8.net/html/gndy/dyzz/list_23_2.html，第三第四页也类似 12345678910111213141516from lxml import etreeimport requestsurl = &apos;http://www.ygdy8.net/html/gndy/dyzz/list_23_1.html&apos;headers = &#123; &apos;User_Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;,&#125;response = requests.get(url,headers=headers)# response.text 是系统自己默认判断。但很遗憾判断错误，导致乱码出现。我们可以采取另外方式 response.content。自己指定格式解码# print(response.text)# print(response.content.decode(&apos;gbk&apos;))print(response.content.decode(encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;)) 先以第一页为例，打印数据如下： 分析电影天堂 html 源代码，可以得出每个 table 标签就是一个电影 通过 xpath 拿到每个电影的详情url1234html = etree.HTML(text)detail_urls = html.xpath(&quot;//table[@class=&apos;tbspan&apos;]//a/@href&quot;)for detail_url in detail_urls: print(detail_url) #加上域名即为详情 url 结果如下： 2、整理代码并爬取前7页的电影列表url12345678910111213141516171819from lxml import etreeimport requests# 域名BASE_DOMAIN = &apos;http://www.ygdy8.net&apos;# url = &apos;http://www.ygdy8.net/html/gndy/dyzz/list_23_1.html&apos;HEADERS = &#123; &apos;User_Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;,&#125;def spider(): base_url = &apos;http://www.ygdy8.net/html/gndy/dyzz/list_23_&#123;&#125;.html&apos; for x in range(1,8): url = base_url.format(x) print(url) # 求出每一页电影列表的url eg: http://www.ygdy8.net/html/gndy/dyzz/list_23_1.htmlif __name__ == &apos;__main__&apos;: spider() 3、爬取每一部电影的详情页地址1234567891011121314151617181920212223def get_detail_urls(url): response = requests.get(url, headers=HEADERS) # response.text 是系统自己默认判断。但很遗憾判断错误，导致乱码出现。我们可以采取另外方式 response.content。自己指定格式解码 # print(response.text) # print(response.content.decode(&apos;gbk&apos;)) # print(response.content.decode(encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;)) text = response.content.decode(encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;) # 通过 xpath 拿到每个电影的详情url html = etree.HTML(text) detail_urls = html.xpath(&quot;//table[@class=&apos;tbspan&apos;]//a/@href&quot;) detail_urls = map(lambda url:BASE_DOMAIN+url,detail_urls) #这句意思相当于下面一段代码:替换列表中的每一个url # def abc(url): # return BASE_DOMAIN+url # index = 1 # for detail_url in detail_urls: # detail_url = abc(detail_url) # detail_urls[index] = detail_url # index+1 return detail_urls 4、抓取电影详情页的数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 解析详情页面def parse_detail_page(url): movie = &#123;&#125; response = requests.get(url,headers = HEADERS) text = response.content.decode(&apos;gbk&apos;, errors=&apos;ignore&apos;) html = etree.HTML(text) # title = html.xpath(&quot;//div[@class=&apos;title_all&apos;]//font[@color=&apos;#07519a&apos;]&quot;) # 本行47行，下面已修改 # 打印出 [&lt;Element font at 0x10cb422c8&gt;, &lt;Element font at 0x10cb42308&gt;] # print(title) # 为了显示，我们需要转一下编码 # for x in title: # print(etree.tostring(x,encoding=&apos;utf-8&apos;).decode(&apos;utf-8&apos;)) # 我们是为了取得文字，所以修改47行 title = html.xpath(&quot;//div[@class=&apos;title_all&apos;]//font[@color=&apos;#07519a&apos;]/text()&quot;)[0] movie[&apos;title&apos;] = title zoomE = html.xpath(&quot;//div[@id=&apos;Zoom&apos;]&quot;) [0] # 求出共同的顶级容器，方便后面求职 imgs = zoomE.xpath(&quot;.//img/@src&quot;) # 求出海报和截图 cover = imgs[0] if len(imgs) &gt; 1: screenshot = imgs[1] movie[&apos;screenshot&apos;] = screenshot # print(cover) movie[&apos;cover&apos;] = cover infos = zoomE.xpath(&quot;.//text()&quot;) for index,info in enumerate(infos): if info.startswith(&apos;◎年 代&apos;): info = info.replace(&quot;◎年 代&quot;, &quot;&quot;).strip() # strip 去掉空格 movie[&apos;year&apos;] = info elif info.startswith(&quot;◎产 地&quot;): info = info.replace(&quot;◎产 地&quot;, &quot;&quot;).strip() movie[&quot;country&quot;] = info elif info.startswith(&quot;◎类 别&quot;): info = info.replace(&quot;◎类 别&quot;, &quot;&quot;).strip() movie[&quot;category&quot;] = info elif info.startswith(&quot;◎豆瓣评分&quot;): info = info.replace(&quot;◎豆瓣评分&quot;, &quot;&quot;).strip() movie[&quot;douban_rating&quot;] = info elif info.startswith(&quot;◎片 长&quot;): info = info.replace(&quot;◎片 长&quot;,&quot;&quot;).strip() movie[&quot;duration&quot;] = info elif info.startswith(&quot;◎导 演&quot;): info = info.replace(&quot;◎导 演&quot;, &quot;&quot;).strip() movie[&quot;director&quot;] = info elif info.startswith(&quot;◎主 演&quot;): actors = [] actor = info.replace(&quot;◎主 演&quot;, &quot;&quot;).strip() actors.append(actor) # 因为主演有很多个，再加上其在电影天堂中元素的特殊性，需要遍历一遍，在分别求出每一个演员 for x in range(index+1,len(infos)): # 从演员 infos 开始遍历，求出每一个演员 actor = infos[x].strip() if actor.startswith(&quot;◎&quot;): # 也就是到了标签 的 ◎ 就退出 break actors.append(actor) movie[&apos;actor&apos;] = actors elif info.startswith(&apos;◎简 介 &apos;): # info = info.replace(&apos;◎简 介 &apos;,&quot;&quot;).strip() for x in range(index+1,len(infos)): if infos[x].startswith(&quot;◎获奖情况&quot;): break profile = infos[x].strip() movie[&apos;profile&apos;] = profile # print(movie) elif info.startswith(&apos;◎获奖情况 &apos;): awards = [] # info = info.replace(&quot;◎获奖情况 &quot;, &quot;&quot;).strip() for x in range(index+1,len(infos)): if infos[x].startswith(&quot;【下载地址】&quot;): break award = infos[x].strip() awards.append(award) movie[&apos;awards&apos;] = awards # print(awards) download_url = html.xpath(&quot;//td[@bgcolor=&apos;#fdfddf&apos;]/a/@href&quot;)[0] movie[&apos;download_url&apos;] = download_url return movie 上述代码爬取了电影的每一个数据。为了让读者方便对照格式，笔者已经下载了写此篇文章时的html—— “movie.html”，放于github 中 最后结果：]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[YYImage源码剖析与学习]]></title>
    <url>%2F2018%2F02%2F23%2FYYImage%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言： 要看懂YYImage框架，最好先了解热身部分(具体的自行百度)，如果懒得看，直接跨过该部分，等到下面部分有疑问，再回过头看这部分的知识，也是可以。 热身部分移动端图片格式调研 1、Image I/OImage I/O 学习笔记Image I/O官方文档GIF图添加文字Demo 使用 CGBitmapContextCreate 函数创建一个位图上下文；使用 CGContextDrawImage 函数将原始位图绘制到上下文中；使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。 2、 CGBitmapContextCreate 中的参数谈谈 iOS 中图片的解压缩 data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可； width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可； bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可； bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化 space ：颜色空间，一般使用 RGB 即可； bitmapInfo ：位图的布局信息。当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst 3、信号量信号量的讲解1234/* 注意，正常的使用顺序是先降低然后再提高，这两个函数通常成对使用。 */ dispatch_semaphore_wait(_framesLock, DISPATCH_TIME_FOREVER); //等待降低信号量 // to do dispatch_semaphore_signal(_framesLock); //提高信号量 所用到的知识：复合赋值运算符、Image I/O、CADisplayLink、willChangeValueForKey:、 一、YYImage总体介绍1、YYImage 源码2、YYImage 源码的文字解析版本 1、YYImage 功能 显示动画类型的图片 播放帧动画 播放 sprite sheet 动画 图片类型探测 图片解码、编码（最核心功能） 2、YYImage 主要类介绍YYImage 类 它是一个完全兼容的“UIImage”子类。它扩展了UIImage支持动画WebP, APNG和GIF格式的图像数据解码。它还支持NSCoding协议，以存档和反存档多帧图像数据。 a、animatedImageMemorySize 如果所有帧图像都被加载到内存中，那么总内存使用(以字节为单位)。如果图像不是从多帧图像数据创建的，则该值为0。 b、preloadAllAnimatedImageFrames 将此属性设置为“YES”将阻塞要解码的调用线程所有动画帧图像到内存，设置为“NO”将释放预装帧。如果图像被许多图像视图(如emoticon)共享，则预加载所有视图帧将降低CPU成本。 YYAnimatedImageView 类 用于显示动画图像的图像视图。可以用来播放多帧动画以及普通动画，可以控制、暂停动画当设备有足够的空闲内存时，这个视图及时请求帧数据。这个视图可以在内部缓冲区中缓存一些或所有未来的帧，以降低CPU成本。 3、YYImage 的意义(图片解码的原因)从磁盘中加载一张图片，并将它显示到屏幕上，这个过程其实经历很多，非常耗性能。随着显示的图片增加，性能下降尤其明显。不管是 JPEG 还是 PNG 等图片，都是一种编码后(压缩)的位图图形格式。我们先看下显示到屏幕这个过程的工作流： 1、我们使用+[UIImage imageWithContentsOfFile:]方法从磁盘中加载一张图片。此时，图片还没有被解码，仍旧是编码状态下。2、返回的图片被分配给UIImageView3、接着一个隐式的 CATransaction 捕获到了图层树的变化；4、在主线程的下一个 run loop到来时，Core Animation 提交了这个隐式的事务，可能会涉及copy这些图片（已经成为图层树中的图层内容的图片）。这个 copy 操作可能会涉及以下部分或全部步骤： a.分配缓冲区来管理文件IO和解压缩操作。 b.文件数据从磁盘读取到内存。 c.将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；d.最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层 图层树：（个人理解）洋葱看过去有很多层，这就是洋葱的图层，而屏幕上显示的文字、图片啊，都可以理解成为图层，很多图层就形成了一个结构，这个很多图层的结构就叫做图层树。 因此，在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解码的原因。 二、YYImage主要类调用逻辑A、渲染GIF/WebP/PNG(APNG)方法调用顺序1、YYImage *image = [YYImage imageNamed:name]; //传入图片名创建YYImage对象 2、[[self alloc] initWithData:data scale:scale];//用重写的方法初始化图像数据 3、YYImageDecoder *decoder = [YYImageDecoder decoderWithData:data scale:scale];//创建解码类 YYImageDecoder 对象，紧接着更新数据 4、result = [self _updateData:data final:final];//根据图像的data算出图片的type以及其他信息，再根据不同type 的图像去分别更新数据 5、[self _updateSourceImageIO];// 计算出PNG、GIF等图片信息（图片的每一帧的属性，包括宽、高、方向、动画重复次数（gif类型）、持续时间（gif类型）） 6、 YYAnimatedImageView *imageView = [[YYAnimatedImageView alloc] initWithImage:image]; //把图片添加到 UIImageView 的子类，这个子类后面讲（第7点后都是它的核心），这里暂且当它为普通 ImageView 那样看。 7、[self setImage:image withType:YYAnimatedImageTypeImage];// 设置图片，类似Setter方法 8、[self imageChanged];//判断当前图片类型以及帧数，由CATransaction支持的显示事务去更新图层的 contentsRect，以及重置动画的参数，后面详解该方法。 9、[self resetAnimated];//重置动画多种参数；[self calcMaxBufferCount]; // 动态调整当前内存的缓冲区大小。 10、[self didMoved];// 窗口对象或者父视图对象改变，则开始控制动画的启动（停止），这是动画得以显示的关键 B、渲染帧动画方法调用顺序1、UIImage *image = [[YYFrameImage alloc] initWithImagePaths:paths oneFrameDuration:0.1 loopCount:0]; //传入图片组的路径、每一个帧（每一个图片）的时间以及循环多少次，计算出总的durations2、[self initWithImagePaths:paths frameDurations:durations loopCount:loopCount];// 把第一张图片解码后返回，并求出第一帧的大小，作为每一帧的大小3、YYAnimatedImageView *imageView = [[YYAnimatedImageView alloc] initWithImage:image];后面步骤跟 渲染GIF/WebP/PNG(APNG)方法调用顺序 第7点开始几乎一样 注意：由于代码过多，不可能面面俱到，所以下面只会摘取核心进行讲解。这样，读者看完此文以及看完我标注过的源码()，，去读源代码，也更容易理解。 三、核心代码1234567891011121314151617181920212223242526272829303132// 它接受一个原始的位图参数 imageRef ，最终返回一个新的解压缩后的位图 newImageCGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) &#123; if (!imageRef) return NULL; size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); if (width == 0 || height == 0) return NULL; // 重新绘制解码(可能会失去一些精度) if (decodeForDisplay) &#123; //decode with redraw (may lose some precision) CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) &#123; hasAlpha = YES; &#125; // BGRA8888 (premultiplied) or BGRX8888 // same as UIGraphicsBeginImageContext() and -[UIView drawRect:] CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo); if (!context) return NULL; CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode CGImageRef newImage = CGBitmapContextCreateImage(context); CFRelease(context); return newImage; // 返回一个新的解压缩后的位图 newImage &#125; else &#123; &#125;&#125; YYCGImageCreateDecodedCopy 是解压缩的核心，也就是渲染图片性能显著的原因。该方法首先求出图片的宽高，注意，这里的图片是指编码前的图片的每一帧图片。 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)imageChanged &#123; YYAnimatedImageType newType = [self currentImageType]; id newVisibleImage = [self imageForType:newType]; NSUInteger newImageFrameCount = 0; BOOL hasContentsRect = NO; if ([newVisibleImage isKindOfClass:[UIImage class]] &amp;&amp; [newVisibleImage conformsToProtocol:@protocol(YYAnimatedImage)]) &#123; // 求出有多少帧（如果是帧动画(由多张图组合的)，相当于有多少张图） newImageFrameCount = ((UIImage&lt;YYAnimatedImage&gt; *) newVisibleImage).animatedImageFrameCount; if (newImageFrameCount &gt; 1) &#123; // 动态图 hasContentsRect = [((UIImage&lt;YYAnimatedImage&gt; *) newVisibleImage) respondsToSelector:@selector(animatedImageContentsRectAtIndex:)]; &#125; &#125; // 由CATransaction支持的显示事务去更新图层的 contentsRect, 但一般不用走这段代码。大都走的是 CATransaction 的隐式事务自己更新 if (!hasContentsRect &amp;&amp; _curImageHasContentsRect) &#123; if (!CGRectEqualToRect(self.layer.contentsRect, CGRectMake(0, 0, 1, 1)) ) &#123; [CATransaction begin]; [CATransaction setDisableActions:YES]; self.layer.contentsRect = CGRectMake(0, 0, 1, 1); [CATransaction commit]; &#125; &#125; _curImageHasContentsRect = hasContentsRect; // YYSpriteSheetImage 类用到，先不理 if (hasContentsRect) &#123; CGRect rect = [((UIImage&lt;YYAnimatedImage&gt; *) newVisibleImage) animatedImageContentsRectAtIndex:0]; [self setContentsRect:rect forImage:newVisibleImage]; &#125; if (newImageFrameCount &gt; 1) &#123; [self resetAnimated]; // 重置动画多种参数，包括在后台释放图像，下面再赋值已经被重置过的动画参数 _curAnimatedImage = newVisibleImage; // 当前动画图片 _curFrame = newVisibleImage; // 当前帧 _totalLoop = _curAnimatedImage.animatedImageLoopCount; // 总循环次数 _totalFrameCount = _curAnimatedImage.animatedImageFrameCount; // 总帧数 [self calcMaxBufferCount]; // 动态调整当前内存的缓冲区大小。 &#125; [self setNeedsDisplay]; // 标志需要重绘，会在下一个循环到来时刷新 [self didMoved]; // 窗口对象或者父视图对象改变，则开始控制动画的启动（停止），这是动画得以显示的关键&#125; 图片改变的处理核心 主要做了以下几点： 初始化动画参数 resetAniamted 初始化或者重置后求出动画播放循环次数、当前帧、总帧数 调用动态调整缓冲区方法 calcMaxBufferCount 、调用控制动画方法 didMoved 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// init the animated params.- (void)resetAnimated &#123; if (!_link) &#123; _lock = dispatch_semaphore_create(1); _buffer = [NSMutableDictionary new]; // 添加到这种队列中的操作，就会自动放到子线程中执行。 _requestQueue = [[NSOperationQueue alloc] init]; /* maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。 为1时，队列为串行队列。只能串行执行。大于1时，队列为并发队列 */ _requestQueue.maxConcurrentOperationCount = 1; /* 初始化一个新的 CADisplayLink 对象，在屏幕更新时调用。为了使显示循环与显示同步，应用程序使用addToRunLoop:forMode:方法将其添加到运行循环中 一个计时器对象，允许应用程序将其绘图同步到显示的刷新率。 */ _link = [CADisplayLink displayLinkWithTarget:[_YYImageWeakProxy proxyWithTarget:self] selector:@selector(step:)]; if (_runloopMode) &#123; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:_runloopMode]; &#125; // 禁用通知 _link.paused = YES; // 接受内存警告的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didReceiveMemoryWarning:) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; // 接受返回后台的通知，返回后台时，记录即将显示的下一帧 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil]; &#125; [_requestQueue cancelAllOperations]; LOCK( if (_buffer.count) &#123; NSMutableDictionary *holder = _buffer; _buffer = [NSMutableDictionary new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; // Capture the dictionary to global queue, // release these images in background to avoid blocking UI thread. [holder class]; // 捕获字典到全局队列，在后台释放这些图像以避免阻塞UI线程。 &#125;); &#125; ); _link.paused = YES; _time = 0; if (_curIndex != 0) &#123; [self willChangeValueForKey:@&quot;currentAnimatedImageIndex&quot;]; _curIndex = 0; // 把索引值重置为0 [self didChangeValueForKey:@&quot;currentAnimatedImageIndex&quot;]; &#125; _curAnimatedImage = nil; // 当前图像为空 _curFrame = nil; // 当前帧 _curLoop = 0; //当前循环次数 _totalLoop = 0; // 总循环次数 _totalFrameCount = 1; // 总帧数 _loopEnd = NO; // 是否循环结尾 _bufferMiss = NO; // 是否丢帧 _incrBufferCount = 0; // 当前允许的缓存&#125; 重置图片的参数；内存警告时释放内存；初始化一个新的 CADisplayLink 对象，在屏幕更新时调用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 只有屏幕刷新累加时间不小于当前帧的动画播放时间才显示图片，播放下一帧。// 播放 GIF 的关键- (void)step:(CADisplayLink *)link &#123; UIImage &lt;YYAnimatedImage&gt; *image = _curAnimatedImage; NSMutableDictionary *buffer = _buffer; // 下一张的图片 UIImage *bufferedImage = nil; // 下一张要显示的索引 NSUInteger nextIndex = (_curIndex + 1) % _totalFrameCount; BOOL bufferIsFull = NO; // // 当前无图像显示 返回 if (!image) return; if (_loopEnd) &#123; // view will keep in last frame // 结束循环 停留在最后帧 [self stopAnimating]; // 如果动画播放循环结束了，就停止动画 return; &#125; NSTimeInterval delay = 0; if (!_bufferMiss) &#123; // 屏幕刷新时间的累加 _time += link.duration; // link.duration 屏幕刷新的时间，默认1/60 s delay = [image animatedImageDurationAtIndex:_curIndex]; // 返回当前帧的持续时间 if (_time &lt; delay) return; _time -= delay; // 减去上一帧播放的时间 if (nextIndex == 0) &#123; _curLoop++; // 增加一轮循环次数 if (_curLoop &gt;= _totalLoop &amp;&amp; _totalLoop != 0) &#123; // 已经到了循环次数，停止播放 _loopEnd = YES; [self stopAnimating]; [self.layer setNeedsDisplay]; // let system call `displayLayer:` before runloop sleep return; // stop at last frame &#125; &#125; delay = [image animatedImageDurationAtIndex:nextIndex]; // 返回下一帧的的持续时间 /** */ if (_time &gt; delay) _time = delay; // do not jump over frame &#125; LOCK( bufferedImage = buffer[@(nextIndex)]; if (bufferedImage) &#123; if ((int)_incrBufferCount &lt; _totalFrameCount) &#123; [buffer removeObjectForKey:@(nextIndex)]; &#125; [self willChangeValueForKey:@&quot;currentAnimatedImageIndex&quot;]; _curIndex = nextIndex; // 用KVO改变 当前索引值 [self didChangeValueForKey:@&quot;currentAnimatedImageIndex&quot;]; _curFrame = bufferedImage == (id)[NSNull null] ? nil : bufferedImage; // 实现YYSpriteSheetImage 的协议方法，才会进入该 if 语句 if (_curImageHasContentsRect) &#123; _curContentsRect = [image animatedImageContentsRectAtIndex:_curIndex]; [self setContentsRect:_curContentsRect forImage:_curFrame]; &#125; nextIndex = (_curIndex + 1) % _totalFrameCount; _bufferMiss = NO; if (buffer.count == _totalFrameCount) &#123; bufferIsFull = YES; // 缓冲区已经满 &#125; &#125; else &#123; // 丢帧，某一帧没有办法找到显示 _bufferMiss = YES; &#125; )//LOCK if (!_bufferMiss) &#123; // 刷新显示图像 [self.layer setNeedsDisplay]; // let system call `displayLayer:` before runloop sleep &#125; /* _YYAnimatedImageViewFetchOperation 为 NSOperation 的子类 还未获取完所有图像，交给它获取下一张图像 */ if (!bufferIsFull &amp;&amp; _requestQueue.operationCount == 0) &#123; // if some work not finished, wait for next opportunity _YYAnimatedImageViewFetchOperation *operation = [_YYAnimatedImageViewFetchOperation new]; operation.view = self; operation.nextIndex = nextIndex; operation.curImage = image; [_requestQueue addOperation:operation]; // &#125;&#125; 这是动画播放的关键，是 CADisplayLink对象 的方法，每 1/60s 也就是屏幕刷新一次就调用一次 123456789101112131415161718192021- (void)calcMaxBufferCount &#123; int64_t bytes = (int64_t)_curAnimatedImage.animatedImageBytesPerFrame; // 求出每一帧的字节数 if (bytes == 0) bytes = 1024; // 如果为0，则给定1024 int64_t total = _YYDeviceMemoryTotal(); // 获取设备的CPU物理内存 int64_t free = _YYDeviceMemoryFree(); // 获取设备的容量 int64_t max = MIN(total * 0.2, free * 0.6); // 比较内存的0.2倍以及容量的0.6倍最小值 max = MAX(max, BUFFER_SIZE); // 如果不够 10 M,则以 10 M 作为最大缓冲区大小 /** _maxBufferSize 内部帧缓冲区大小 * 当设备有足够的空闲内存时，这个视图将请求并解码一些或所有未来的帧图像进入一个内部缓冲区。 * 默认值为0 如果这个属性的值是0，那么最大缓冲区大小将根据当前的状态进行动态调整设备释放内存。否则，缓冲区大小将受到此值的限制。 * 当收到内存警告或应用程序进入后台时，缓冲区将被立即释放 */ if (_maxBufferSize) max = max &gt; _maxBufferSize ? _maxBufferSize : max; //得出缓冲区的最大值 double maxBufferCount = (double)max / (double)bytes; if (maxBufferCount &lt; 1) maxBufferCount = 1; else if (maxBufferCount &gt; 512) maxBufferCount = 512; _maxBufferCount = maxBufferCount; // 最大缓冲数&#125; 动态求出最大缓冲数—&gt;参考 123456789101112131415161718192021222324252627282930313233343536373839404142/* 从自定义的 start 方法中调用 main 方法 调用[self didMoved]; 从而调用此方法*/- (void)main &#123; __strong YYAnimatedImageView *view = _view; if (!view) return; if ([self isCancelled]) return; view-&gt;_incrBufferCount++; //动态调整当前内存的缓冲区大小。 if (view-&gt;_incrBufferCount == 0) [view calcMaxBufferCount]; if (view-&gt;_incrBufferCount &gt; (NSInteger)view-&gt;_maxBufferCount) &#123; view-&gt;_incrBufferCount = view-&gt;_maxBufferCount; &#125; NSUInteger idx = _nextIndex; // 获取 Operation 中传过来的 下一个索引值 NSUInteger max = view-&gt;_incrBufferCount &lt; 1 ? 1 : view-&gt;_incrBufferCount; // 当前的缓冲区计数 NSUInteger total = view-&gt;_totalFrameCount; // 总图片帧数 view = nil; for (int i = 0; i &lt; max; i++, idx++) &#123; @autoreleasepool &#123; if (idx &gt;= total) idx = 0; if ([self isCancelled]) break; __strong YYAnimatedImageView *view = _view; if (!view) break; LOCK_VIEW(BOOL miss = (view-&gt;_buffer[@(idx)] == nil)); // 拿索引值去当前缓冲区取图片 // 如果没有取到图片，则在子线程重新解码，得到解码后的图片 if (miss) &#123; // 等到当前还未解码的图片 UIImage *img = [_curImage animatedImageFrameAtIndex:idx]; NSLog(@&quot;当前线程---%@&quot;, [NSThread currentThread]); // 打印当前线程，每次打印都是 name = (null)，说明在异步线程 // 在异步线程再次调用解码图片，如果无法解码或已经解码就返回self img = img.yy_imageByDecoded; if ([self isCancelled]) break; LOCK_VIEW(view-&gt;_buffer[@(idx)] = img ? img : [NSNull null]); // 每次添加一张图片到 _buffer 数组 view = nil; &#125; &#125; &#125;&#125; 该方法负责把图片存入缓冲区中。（过程：取未解码图片–&gt;解码存入缓冲区） 在此，对YYImage框架完毕了，希望大家都能从大神源码学到知识。 其他额外收获：1、是否模拟器123456789- (BOOL)isSimulator &#123; size_t size; sysctlbyname(&quot;hw.machine&quot;, NULL, &amp;size, NULL, 0); char *machine = malloc(size); sysctlbyname(&quot;hw.machine&quot;, machine, &amp;size, NULL, 0); NSString *model = [NSString stringWithUTF8String:machine]; free(machine); return [model isEqualToString:@&quot;x86_64&quot;] || [model isEqualToString:@&quot;i386&quot;];&#125; 2、根据不同的系统 scale 选择图片123456789101112131415161718/** 一个NSNumber对象数组，根据不同的系统scale返回数组内部不同顺序的数字e.g. iPhone3GS:@[@1,@2,@3] iPhone5:@[@2,@3,@1] iPhone6 Plus:@[@3,@2,@1]*/static NSArray *_NSBundlePreferredScales() &#123; static NSArray *scales; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; CGFloat screenScale = [UIScreen mainScreen].scale; if (screenScale &lt;= 1) &#123; scales = @[@1,@2,@3]; &#125; else if (screenScale &lt;= 2) &#123; scales = @[@2,@3,@1]; &#125; else &#123; scales = @[@3,@2,@1]; &#125; &#125;); return scales;&#125; 咋一看，这不是单例吗？保证初始化代码只执行一次，可移步单例相关文章 3、判断图片后缀1234567891011NSArray *exts = ext.length &gt; 0 ? @[ext] : @[@&quot;&quot;, @&quot;png&quot;, @&quot;jpeg&quot;, @&quot;jpg&quot;, @&quot;gif&quot;, @&quot;webp&quot;, @&quot;apng&quot;];NSArray *scales = _NSBundlePreferredScales();for (int s = 0; s &lt; scales.count; s++) &#123; scale = ((NSNumber *)scales[s]).floatValue; NSString *scaledName = _NSStringByAppendingNameScale(res, scale); for (NSString *e in exts) &#123; path = [[NSBundle mainBundle] pathForResource:scaledName ofType:e]; if (path) break; &#125; if (path) break;&#125; 如果图片没标明后缀，则遍历后缀数组，并添加后缀到传进来的图片名，最后到 mainBundle 里面取图片路径，取到地址则停止 CF_RETURNS_RETAINED 标记返回CF类型的函数，该类型需要调用方释放NSDefaultRunLoopMode 保持gif 图在scrollView 拉动时不停止|= 为按位或运算符 eg: a|=b; 相当于 a=a|b; 参考：快速解决GIF图的锯齿问题]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJRefresh源码剖析与学习]]></title>
    <url>%2F2018%2F02%2F14%2FMJRefresh%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[MJRefresh是李明杰大神的开源框架,这是一款十分优雅的刷新组件库，这开源组件无论从代码风格，可用性，易读性还是兼容性来讲都十分优秀。本文就最新MJRefresh版本来讲解。耐心看下去，本文和纯解读源码的文章不同。本文码字几天，如果对您有帮助，给个鼓励，谢谢大家！ MJRefresh 一、MJRefreshComponent1.导入文件123456#import &lt;UIKit/UIKit.h&gt;#import &quot;MJRefreshConst.h&quot;#import &quot;UIView+MJExtension.h&quot;#import &quot;UIScrollView+MJExtension.h&quot;#import &quot;UIScrollView+MJRefresh.h&quot;#import &quot;NSBundle+MJRefresh.h&quot; 2.状态枚举12345678910111213/** 刷新控件的状态 */typedef NS_ENUM(NSInteger, MJRefreshState) &#123; /** 普通闲置状态 */ MJRefreshStateIdle = 1, /** 松开就可以进行刷新的状态 */ MJRefreshStatePulling, /** 正在刷新中的状态 */ MJRefreshStateRefreshing, /** 即将刷新的状态 */ MJRefreshStateWillRefresh, /** 所有数据加载完毕，没有更多的数据了 */ MJRefreshStateNoMoreData&#125;; 3、刷新回调123456789101112#pragma mark - 刷新回调/** 正在刷新的回调 */@property (copy, nonatomic) MJRefreshComponentRefreshingBlock refreshingBlock;/** 设置回调对象和回调方法 */- (void)setRefreshingTarget:(id)target refreshingAction:(SEL)action;/** 回调对象 */@property (weak, nonatomic) id refreshingTarget;/** 回调方法 */@property (assign, nonatomic) SEL refreshingAction;/** 触发回调（交给子类去调用） */- (void)executeRefreshingCallback; 4、刷新状态控制12345678910111213141516#pragma mark - 刷新状态控制/** 进入刷新状态 */- (void)beginRefreshing;- (void)beginRefreshingWithCompletionBlock:(void (^)(void))completionBlock;/** 开始刷新后的回调(进入刷新状态后的回调) */@property (copy, nonatomic) MJRefreshComponentbeginRefreshingCompletionBlock beginRefreshingCompletionBlock;/** 结束刷新的回调 */@property (copy, nonatomic) MJRefreshComponentEndRefreshingCompletionBlock endRefreshingCompletionBlock;/** 结束刷新状态 */- (void)endRefreshing;- (void)endRefreshingWithCompletionBlock:(void (^)(void))completionBlock;/** 是否正在刷新 */@property (assign, nonatomic, readonly, getter=isRefreshing) BOOL refreshing;//- (BOOL)isRefreshing;/** 刷新状态 一般交给子类内部实现 */@property (assign, nonatomic) MJRefreshState state; 具体方法分析：12345678910111213141516171819#pragma mark 进入刷新状态- (void)beginRefreshing&#123; [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123; self.alpha = 1.0; &#125;]; self.pullingPercent = 1.0; // 只要正在刷新，就完全显示 if (self.window) &#123; self.state = MJRefreshStateRefreshing; &#125; else &#123; // 预防正在刷新中时，调用本方法使得header inset回置失败 if (self.state != MJRefreshStateRefreshing) &#123; self.state = MJRefreshStateWillRefresh; // 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下) [self setNeedsDisplay]; &#125; &#125;&#125; 上面做了一个动画效果，多加了一个willRefresh的状态，我的理解是为了防止self.window为空的时候，突然刷新崩溃（从另一个页面返回的时候），所以需要一个状态来过渡。 设置state会调用setNeedsLayout方法；如果self.window为空，把状态改成即将刷新，并调用setNeedsDisplay 首先UIView的setNeedsDisplay和setNeedsLayout方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到 UIGraphicsGetCurrentContext，就可以绘制了，而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。 综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便出来数据。 1234567//结束刷新- (void)endRefreshing&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.state = MJRefreshStateIdle; &#125;);&#125; 在主线程结束刷新，把刷新状态改为普通闲置状态 5、KVO监听123456789101112131415161718192021222324252627282930313233343536#pragma mark - KVO监听- (void)addObservers&#123; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil]; [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil]; self.pan = self.scrollView.panGestureRecognizer; [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];&#125;- (void)removeObservers&#123; [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentOffset]; [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentSize]; [self.pan removeObserver:self forKeyPath:MJRefreshKeyPathPanState]; self.pan = nil;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; // 遇到这些情况就直接返回 if (!self.userInteractionEnabled) return; // 这个就算看不见也需要处理 if ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123; [self scrollViewContentSizeDidChange:change]; &#125; // 看不见 if (self.hidden) return; if ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123; [self scrollViewContentOffsetDidChange:change]; &#125; else if ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123; [self scrollViewPanStateDidChange:change]; &#125;&#125; 监听ContentOffset、ContentSize、手势的State 6、回调123456789101112131415#pragma mark - 内部方法- (void)executeRefreshingCallback&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (self.refreshingBlock) &#123; self.refreshingBlock(); &#125; if ([self.refreshingTarget respondsToSelector:self.refreshingAction]) &#123; MJRefreshMsgSend(MJRefreshMsgTarget(self.refreshingTarget), self.refreshingAction, self); &#125; if (self.beginRefreshingCompletionBlock) &#123; self.beginRefreshingCompletionBlock(); &#125; &#125;);&#125; MJRefreshMsgSend是时运行时objc_msgSend，第一个参数代表接收者，第二个参数代表选择子（SEL是选择子的类型），后续参数就是消息中的那些参数，其顺序不变。选择子指的就是方法的名字。 二、MJRefreshHeader1、初始化（构造方法）12345678910111213#pragma mark - 构造方法+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock&#123; MJRefreshHeader *cmp = [[self alloc] init]; cmp.refreshingBlock = refreshingBlock; return cmp;&#125;+ (instancetype)headerWithRefreshingTarget:(id)target refreshingAction:(SEL)action&#123; MJRefreshHeader *cmp = [[self alloc] init]; [cmp setRefreshingTarget:target refreshingAction:action]; return cmp;&#125; 2、覆盖父类方法123456789101112131415161718- (void)prepare&#123; [super prepare]; // 设置key self.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey; // 设置高度 self.mj_h = MJRefreshHeaderHeight;&#125;- (void)placeSubviews&#123; [super placeSubviews]; // 设置y值(当自己(头部)的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值) self.mj_y = - self.mj_h - self.ignoredScrollViewContentInsetTop;&#125; prepare设置一下初始化值数据。而placeSubViews更新一下UI。 3、滚动时偏移值变化以及状态的改变12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//当scrollView的contentOffset发生改变的时候调用- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#123; [super scrollViewContentOffsetDidChange:change]; // 在刷新的refreshing状态 if (self.state == MJRefreshStateRefreshing) &#123; // 暂时保留 if (self.window == nil) return; // sectionheader停留解决 //刷新的时候:偏移量（self.scrollView.mj_offsetY） = 状态栏 + 导航栏 + header的高度（54+64=118 iphoneX则为54+88=142） //内边距高度（_scrollViewOriginalInset.top）= 状态栏 + 导航栏 = 64 CGFloat insetT = - self.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top; insetT = insetT &gt; self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT; self.scrollView.mj_insetT = insetT; self.insetTDelta = _scrollViewOriginalInset.top - insetT; return; &#125; // 跳转到下一个控制器时，contentInset可能会变 _scrollViewOriginalInset = self.scrollView.mj_inset; // 当前的contentOffset CGFloat offsetY = self.scrollView.mj_offsetY; // 头部控件刚好出现的offsetY CGFloat happenOffsetY = - self.scrollViewOriginalInset.top; // 如果是向上滚动到看不见头部控件，直接返回 // &gt;= -&gt; &gt; if (offsetY &gt; happenOffsetY) return; // 普通闲置 即将刷新 的临界点 //个人觉得normal2pullingOffsetY应该是头部完全出来时的Y轴偏移值 CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h; CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h; if (self.scrollView.isDragging) &#123; // 如果正在拖拽 self.pullingPercent = pullingPercent; if (self.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123; //手指拖拽中，状态是默认状态以及下拉距离（偏移值）大于临界点距离 // 转为可以进行刷新状态 self.state = MJRefreshStatePulling; &#125; else if (self.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123; //手指拖拽中，状态是默认状态以及下拉距离（偏移值）小于临界点距离，也就是拖得比较下 // 转为普通状态 self.state = MJRefreshStateIdle; &#125; &#125; else if (self.state == MJRefreshStatePulling) &#123;// 即将刷新 &amp;&amp; 手松开 // 开始刷新 [self beginRefreshing]; &#125; else if (pullingPercent &lt; 1) &#123; self.pullingPercent = pullingPercent;//手松开后，默认状态时，恢复self.pullingPercent &#125;&#125; 状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。 手指还贴在屏幕的时候是不能进行刷新的。即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。一旦手指离开了屏幕，马上将状态切换为正在刷新。 普通闲置与即将刷新的分界点，看下图，一目了然 4、改变状态时的相应操作（setter方法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)setState:(MJRefreshState)state&#123; MJRefreshCheckState //MJRefreshCheckState是宏，其实也就是下面语句，为了检测状态是否相同，相同则return// MJRefreshState oldState = self.state;// if (state == oldState) &#123;// NSLog(@&quot;相同&quot;);// return;// &#125;// [super setState:state]; // 根据状态做事情 if (state == MJRefreshStateIdle) &#123; if (oldState != MJRefreshStateRefreshing) return; // 保存刷新时间 [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey]; [[NSUserDefaults standardUserDefaults] synchronize]; // 恢复inset和offset [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123; //此时要加上scrollView刷新时跟普通闲置时的偏移差值(刷新时偏移值为118或者142，self.insetTDelta值为header高度-54)，恢复后self.scrollView.mj_insetT = 64（或者88） self.scrollView.mj_insetT += self.insetTDelta; // 自动调整透明度 if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0; &#125; completion:^(BOOL finished) &#123; self.pullingPercent = 0.0; if (self.endRefreshingCompletionBlock) &#123; self.endRefreshingCompletionBlock(); &#125; &#125;]; &#125; else if (state == MJRefreshStateRefreshing) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123; CGFloat top = self.scrollViewOriginalInset.top + self.mj_h; // 增加滚动区域top self.scrollView.mj_insetT = top; //增加滚动区域top(赋值给scrollView.inset.top) CGPoint offset = self.scrollView.contentOffset; offset.y = -top; [self.scrollView setContentOffset:offset animated:NO]; &#125; completion:^(BOOL finished) &#123; //执行正在刷新的回调 [self executeRefreshingCallback]; &#125;]; &#125;); &#125;&#125; 注意[super setState:state]的位置，等基类的state赋值给oldState，再跟新状态对比，对比完后，再[super setState:state]调用基类,从而赋值基类state 该方法主要要注意状态在普通闲置状态以及刷新状态的scrollView.contentOffset变化 三、MJRefreshStateHeader该类是MJRefreshHeader的子类，主要用来设置显示上一次刷新时间的label：lastUpdatedTimeLabel和显示刷新状态的label：stateLabel属性等 1、stateLabel初始化方法1234567891011121314151617181920- (void)setTitle:(NSString *)title forState:(MJRefreshState)state&#123; if (title == nil) return; self.stateTitles[@(state)] = title; self.stateLabel.text = self.stateTitles[@(self.state)];&#125;#pragma mark - 覆盖父类的方法- (void)prepare&#123; [super prepare]; // 初始化间距 self.labelLeftInset = MJRefreshLabelLeftInset; // 初始化文字 [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle]; [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling]; [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];&#125; prepare初始化方法，实现本地化（不同字体），并根据不同状态赋值给stateLabel 2、lastUpdatedLabel赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#pragma mark key的处理- (void)setLastUpdatedTimeKey:(NSString *)lastUpdatedTimeKey&#123; [super setLastUpdatedTimeKey:lastUpdatedTimeKey]; // 如果label隐藏了，就不用再处理 if (self.lastUpdatedTimeLabel.hidden) return; NSDate *lastUpdatedTime = [[NSUserDefaults standardUserDefaults] objectForKey:lastUpdatedTimeKey]; // 如果有block //用户定义的时间格式 if (self.lastUpdatedTimeText) &#123; self.lastUpdatedTimeLabel.text = self.lastUpdatedTimeText(lastUpdatedTime); return; &#125; if (lastUpdatedTime) &#123; // 1.获得年月日 NSCalendar *calendar = [self currentCalendar]; NSUInteger unitFlags = NSCalendarUnitYear| NSCalendarUnitMonth | NSCalendarUnitDay |NSCalendarUnitHour |NSCalendarUnitMinute; NSDateComponents *cmp1 = [calendar components:unitFlags fromDate:lastUpdatedTime]; NSDateComponents *cmp2 = [calendar components:unitFlags fromDate:[NSDate date]]; // 2.格式化日期 NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; BOOL isToday = NO; if ([cmp1 day] == [cmp2 day]) &#123; // 今天 formatter.dateFormat = @&quot; HH:mm&quot;; //返回11：11样式 isToday = YES; &#125; else if ([cmp1 year] == [cmp2 year]) &#123; // 今年 formatter.dateFormat = @&quot;MM-dd HH:mm&quot;; //返回02-08 11：11样式 &#125; else &#123; formatter.dateFormat = @&quot;yyyy-MM-dd HH:mm&quot;; //返回2018-02-08 11：11样式 &#125; NSString *time = [formatter stringFromDate:lastUpdatedTime]; // 3.显示日期 //[NSBundle mj_localizedStringForKey:MJRefreshHeaderLastTimeText] 会返回简体（英文、繁体）的 【最后更新：】 //isToday ? [NSBundle mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : @&quot;&quot; 如果上一次刷新也是今天，则返回简体（英文、繁体）的 【今天】,不是则返回空字符串 self.lastUpdatedTimeLabel.text = [NSString stringWithFormat:@&quot;%@%@%@&quot;, [NSBundle mj_localizedStringForKey:MJRefreshHeaderLastTimeText], isToday ? [NSBundle mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : @&quot;&quot;, time]; &#125; else &#123; //没有获得上次更新时间 self.lastUpdatedTimeLabel.text = [NSString stringWithFormat:@&quot;%@%@&quot;, [NSBundle mj_localizedStringForKey:MJRefreshHeaderLastTimeText], [NSBundle mj_localizedStringForKey:MJRefreshHeaderNoneLastDateText]]; &#125;&#125; 注意一下时间格式，本地化以及不同上次刷新时间的lastUpdatedTimeLabel显示上面代码还给用户自定义时间格式，没有才使用默认，默认的格式逻辑显示，我已在上面注释清楚 MJRefreshNormalHeader和MJRefreshGifHeader都是MJRefreshStateHeader的子类，前者和后者的布局一样，不同的就是header左边一个是菊花的样式，另外一个是gif，详看下图： 由此看来，这两种形式的header都有相同的共性，我们在做类似的功能时，如果有几个控件或者几个类共性一样，比如说，一个保险类（InsuranceClass），一个房地产类（RealEstateClass），他们可以有一个基类销售类（SalesClass），SalesClass拥有销售员工、顾客、金额、销售日期等 保险类 和 房地产类 需要的共同属性 四、MJRefreshNormalHeader 1、在MJRefreshStateHeader上添加了箭头和菊花 2、布局这两种样式View,且在状态切换时更改样式切换 1、圈圈（菊花）和箭头的布局1234567891011121314151617181920212223242526272829303132- (void)placeSubviews&#123; [super placeSubviews]; // 箭头的中心点 CGFloat arrowCenterX = self.mj_w * 0.5; if (!self.stateLabel.hidden) &#123; CGFloat stateWidth = self.stateLabel.mj_textWith; //状态label文字的宽度 CGFloat timeWidth = 0.0; if (!self.lastUpdatedTimeLabel.hidden) &#123; timeWidth = self.lastUpdatedTimeLabel.mj_textWith; //时间label文字的宽度 &#125; CGFloat textWidth = MAX(stateWidth, timeWidth); //求出一个最宽的文字宽度 arrowCenterX -= textWidth / 2 + self.labelLeftInset; //箭头(菊花)中心点x还要减去（最宽的文字宽度/2 + 文字距离圈圈、箭头的距离） &#125; //中心点y设置为header的高度的一半 CGFloat arrowCenterY = self.mj_h * 0.5; CGPoint arrowCenter = CGPointMake(arrowCenterX, arrowCenterY); // 箭头 if (self.arrowView.constraints.count == 0) &#123; //箭头没有其他布局约束 self.arrowView.mj_size = self.arrowView.image.size; //箭头大小跟提供的arrowView图片大小一致 self.arrowView.center = arrowCenter; &#125; // 圈圈 if (self.loadingView.constraints.count == 0) &#123; //圈圈(菊花)没有其他布局约束 self.loadingView.center = arrowCenter; &#125; self.arrowView.tintColor = self.stateLabel.textColor;&#125; 上面代码主要实现了圈圈（菊花）和箭头的布局，需要注意的是让箭头菊花紧跟刷新文字或者状态文字居中的逻辑，我已在注释写明 2、不同状态下菊花和箭头的互换1234567891011121314151617181920212223242526272829303132333435363738- (void)setState:(MJRefreshState)state&#123; MJRefreshCheckState // 根据状态做事情 if (state == MJRefreshStateIdle) &#123; if (oldState == MJRefreshStateRefreshing) &#123; //上次状态是正在刷新，准备改变成普通闲置状态 self.arrowView.transform = CGAffineTransformIdentity; //仿射变换初始化 [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123; self.loadingView.alpha = 0.0; //把菊花变成完全透明 &#125; completion:^(BOOL finished) &#123; // 如果执行完动画发现不是idle状态，就直接返回，进入其他状态 if (self.state != MJRefreshStateIdle) return;// self.loadingView.backgroundColor = [UIColor greenColor]; self.loadingView.alpha = 1.0; //菊花变成完全显示 （为什么要这样？求大佬告诉） [self.loadingView stopAnimating]; //菊花停止转动，同时会隐藏菊花（loadingView.hidesWhenStopped = YES;） self.arrowView.hidden = NO; //箭头显示 &#125;]; &#125; else &#123; //上次状态是拖拽或者普通闲置状态，准备改变成普通闲置状态 --&gt; 把菊花停止转动，菊花隐藏，箭头显示 [self.loadingView stopAnimating]; self.arrowView.hidden = NO; [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123; self.arrowView.transform = CGAffineTransformIdentity; //在操作结束之后对箭头设置量进行还原 &#125;]; &#125; &#125; else if (state == MJRefreshStatePulling) &#123; //拖拽状态：菊花停止转动，箭头显示 [self.loadingView stopAnimating]; self.arrowView.hidden = NO; [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123; self.arrowView.transform = CGAffineTransformMakeRotation(0.000001 - M_PI);//(改变箭头的方向，但是为什么要0.000001 - M_PI？) &#125;]; &#125; else if (state == MJRefreshStateRefreshing) &#123; //正在刷新状态：菊花完全显示并且开始转动，箭头隐藏 self.loadingView.alpha = 1.0; // 防止refreshing -&gt; idle的动画完毕动作没有被执行 [self.loadingView startAnimating]; self.arrowView.hidden = YES; &#125;&#125; 通过不同的状态控制菊花和箭头的隐藏和消失，及他们的动画效果，如箭头的朝上朝下，和菊花的转与不转 四、MJRefreshGifHeader 1、加载不同状态对应的动画图片2、设置不同状态对应的动画时间 1、懒加载1234567891011121314151617181920212223242526#pragma mark - 懒加载//gigView显示gif- (UIImageView *)gifView&#123; if (!_gifView) &#123; UIImageView *gifView = [[UIImageView alloc] init]; [self addSubview:_gifView = gifView]; &#125; return _gifView; &#125;- (NSMutableDictionary *)stateImages &#123; if (!_stateImages) &#123; self.stateImages = [NSMutableDictionary dictionary]; &#125; return _stateImages; &#125;- (NSMutableDictionary *)stateDurations &#123; if (!_stateDurations) &#123; self.stateDurations = [NSMutableDictionary dictionary]; &#125; return _stateDurations; &#125; 2、设置不通过状态对应的动画图片以及动画时间12345678910111213141516171819#pragma mark - 公共方法- (void)setImages:(NSArray *)images duration:(NSTimeInterval)duration forState:(MJRefreshState)state &#123; if (images == nil) return; self.stateImages[@(state)] = images; self.stateDurations[@(state)] = @(duration); /* 根据图片设置控件的高度 */ UIImage *image = [images firstObject]; if (image.size.height &gt; self.mj_h) &#123; self.mj_h = image.size.height; &#125; &#125;- (void)setImages:(NSArray *)images forState:(MJRefreshState)state &#123; [self setImages:images duration:images.count * 0.1 forState:state]; &#125; 3、实现图片的切换和gifView布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma mark - 实现父类的方法- (void)prepare&#123; [super prepare]; // 初始化间距 self.labelLeftInset = 20;&#125;//根据拖拽进度设置透明度- (void)setPullingPercent:(CGFloat)pullingPercent&#123; [super setPullingPercent:pullingPercent]; NSArray *images = self.stateImages[@(MJRefreshStateIdle)]; //选择闲置状态下的图片组 if (self.state != MJRefreshStateIdle || images.count == 0) return; //状态不是闲置或者图片为空，则直接返回 // 停止动画 [self.gifView stopAnimating]; // 设置当前需要显示的图片 NSUInteger index = images.count * pullingPercent; if (index &gt;= images.count) index = images.count - 1; self.gifView.image = images[index];&#125;- (void)placeSubviews&#123; [super placeSubviews]; if (self.gifView.constraints.count) return; //gifView没有约束，直接返回 self.gifView.frame = self.bounds; if (self.stateLabel.hidden &amp;&amp; self.lastUpdatedTimeLabel.hidden) &#123; //上次刷新时间和状态文字都隐藏了，图片内容就居ifView中间显示 self.gifView.contentMode = UIViewContentModeCenter; &#125; else &#123; //图片居gifView右边显示 self.gifView.contentMode = UIViewContentModeRight; //下面代码同样也是为了让gifView紧挨着文字居中显示。算出最长的文字，通过减去文字的一般宽度，调整gifView的x值，跟NormalHeader的方法一样，详细请看normalHeader CGFloat stateWidth = self.stateLabel.mj_textWith; CGFloat timeWidth = 0.0; if (!self.lastUpdatedTimeLabel.hidden) &#123; timeWidth = self.lastUpdatedTimeLabel.mj_textWith; &#125; CGFloat textWidth = MAX(stateWidth, timeWidth); self.gifView.mj_w = self.mj_w * 0.5 - textWidth * 0.5 - self.labelLeftInset; &#125;&#125;- (void)setState:(MJRefreshState)state&#123; MJRefreshCheckState // 根据状态做事情 if (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123; //状态变为拖拽或者正在刷新，获取各自状态该显示的图片组 NSArray *images = self.stateImages[@(state)]; if (images.count == 0) return; [self.gifView stopAnimating]; if (images.count == 1) &#123; // 单张图片 self.gifView.image = [images lastObject]; &#125; else &#123; // 多张图片 self.gifView.animationImages = images; self.gifView.animationDuration = [self.stateDurations[@(state)] doubleValue]; [self.gifView startAnimating]; &#125; &#125; else if (state == MJRefreshStateIdle) &#123; [self.gifView stopAnimating]; &#125;&#125; 到此，我对MJRefreshHeader那一块的源码已经读完，剩下MJRefreshFooter，但由于实现逻辑基本一致，故在此不再详说。迟点，发现MJRefreshFooter有其他特殊之处，我会更新此文，谢谢大家！ 学习1、巧用Model我们可能见到一些开发者会在didSelectRowAtIndexPath协议方法里面这样写 1234567891011121314151617181920212223- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; MJExample *exam = self.examples[indexPath.section]; UIViewController *vc = [[exam.vcClass alloc] init]; vc.title = exam.titles[indexPath.row]; [vc setValue:exam.methods[indexPath.row] forKeyPath:@&quot;method&quot;]; [self.navigationController pushViewController:vc animated:YES]; if (indexPath.row == 0) &#123; UIViewController *test1 = [UIViewController new]; test1.title = @&quot;test1&quot;; [self.navigationController pushViewController:test1 animated:YES]; &#125;else if (indexPath.row == 1) &#123; UIViewController *test2 = [UIViewController new]; test2.title = @&quot;test2&quot;; [self.navigationController pushViewController:test2 animated:YES]; &#125;else if (indexPath.row == 2) &#123; UIViewController *test3 = [UIViewController new]; test3.title = @&quot;test3&quot;; [self.navigationController pushViewController:test3 animated:YES]; &#125;else &#123; ; &#125;&#125; 这样会造成didSelectRowAtIndexPath方法过于臃肿，且重复代码过多，太多if else 或者 switch，我们可以用Model很好的解决这个问题，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940- (NSArray *)examples&#123; if (!_examples) &#123; MJExample *exam0 = [[MJExample alloc] init]; exam0.header = MJExample00; exam0.vcClass = [MJTableViewController class]; exam0.titles = @[@&quot;默认&quot;, @&quot;动画图片&quot;, @&quot;隐藏时间&quot;, @&quot;隐藏状态和时间&quot;, @&quot;自定义文字&quot;, @&quot;自定义刷新控件&quot;]; exam0.methods = @[@&quot;example01&quot;, @&quot;example02&quot;, @&quot;example03&quot;, @&quot;example04&quot;, @&quot;example05&quot;, @&quot;example06&quot;]; MJExample *exam1 = [[MJExample alloc] init]; exam1.header = MJExample10; exam1.vcClass = [MJTableViewController class]; exam1.titles = @[@&quot;默认&quot;, @&quot;动画图片&quot;, @&quot;隐藏刷新状态的文字&quot;, @&quot;全部加载完毕&quot;, @&quot;禁止自动加载&quot;, @&quot;自定义文字&quot;, @&quot;加载后隐藏&quot;, @&quot;自动回弹的上拉01&quot;, @&quot;自动回弹的上拉02&quot;, @&quot;自定义刷新控件(自动刷新)&quot;, @&quot;自定义刷新控件(自动回弹)&quot;]; exam1.methods = @[@&quot;example11&quot;, @&quot;example12&quot;, @&quot;example13&quot;, @&quot;example14&quot;, @&quot;example15&quot;, @&quot;example16&quot;, @&quot;example17&quot;, @&quot;example18&quot;, @&quot;example19&quot;, @&quot;example20&quot;, @&quot;example21&quot;]; MJExample *exam2 = [[MJExample alloc] init]; exam2.header = MJExample20; exam2.vcClass = [MJCollectionViewController class]; exam2.titles = @[@&quot;上下拉刷新&quot;]; exam2.methods = @[@&quot;example21&quot;]; MJExample *exam3 = [[MJExample alloc] init]; exam3.header = MJExample30; exam3.vcClass = [MJWebViewViewController class]; exam3.titles = @[@&quot;下拉刷新&quot;]; exam3.methods = @[@&quot;example31&quot;]; self.examples = @[exam0, exam1, exam2, exam3]; &#125; return _examples;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; MJExample *exam = self.examples[indexPath.section]; UIViewController *vc = [[exam.vcClass alloc] init]; vc.title = exam.titles[indexPath.row]; [vc setValue:exam.methods[indexPath.row] forKeyPath:@&quot;method&quot;]; [self.navigationController pushViewController:vc animated:YES];&#125; 2、跳转巧用ViewController.h1234567- (IBAction)tappdeBtn:(id)sender &#123; UIViewController *vc = [[BViewController alloc] init]; vc.title = @&quot;example01&quot;; [vc setValue:@&quot;example01&quot; forKeyPath:@&quot;method&quot;]; [self.navigationController pushViewController:vc animated:YES]; &#125; 上面是跳转方法，请留意[vc setValue:@&quot;example01&quot; forKeyPath:@&quot;method&quot;];这句代码，下面会详解 BViewController.h123456789101112131415161718192021222324#import &quot;BViewController.h&quot;#import &quot;UIViewController+Example.h&quot;#define MJPerformSelectorLeakWarning(Stuff) \do &#123; \_Pragma(&quot;clang diagnostic push&quot;) \_Pragma(&quot;clang diagnostic ignored \&quot;-Warc-performSelector-leaks\&quot;&quot;) \Stuff; \_Pragma(&quot;clang diagnostic pop&quot;) \&#125; while (0)@implementation BViewController- (void)viewDidLoad &#123; [super viewDidLoad]; MJPerformSelectorLeakWarning( [self performSelector:NSSelectorFromString(self.method) withObject:nil]; );&#125;- (void)example01&#123; NSLog(@&quot;进入此方法&quot;);&#125; 结果： 1、由上可以看到[self performSelector:NSSelectorFromString(self.method) withObject:nil];没有指明方法名，仍可以调用- (void)example01(),这是运用了runtime的黑魔法，定义了UIViewController+Example分类方法，runtime的使用可以看我之前的文章–&gt;iOS进阶之runtime作用 2、MJPerformSelectorLeakWarning( );如果selector是在运行时才确定的，performSelector时，若先把selector保存起来，等到某事件发生后再调用，相当于在动态绑定之上再使用动态绑定，不过这是编译器不知道要执行的selector是什么，因为这必须到了运行时才能确定，使用这种特性的代价是，如果在ARC下编译代码，编译器会发生警告,可用#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;忽略警告 1234567891011121314151617181920212223#import &lt;UIKit/UIKit.h&gt;@interface UIViewController (Example)@property (copy, nonatomic) NSString *method;@end----------------------------#import &quot;UIViewController+Example.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (Example)static char MethodKey;- (void)setMethod:(NSString *)method&#123; objc_setAssociatedObject(self, &amp;MethodKey, method, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)method&#123; return objc_getAssociatedObject(self, &amp;MethodKey);&#125; 这是runtime中为分类添加属性的经典用法，把上面跳转方法中的[vc setValue:@&quot;example01&quot; forKeyPath:@&quot;method&quot;];赋值的example01 利用runtime关联，这样分类中的method属性值就为example01 解析一下 static char 123456比如有这样一个函数exp()&#123;char a[] = &quot;Hello!&quot; ;static char b[] = &quot;Hello!&quot; ;&#125; 当调用这个函数完后，a[]就不存在了，而b[]依然存在，并且值为hello; 参考：performSelector系列方法编译器警告-Warc-performSelector-leaks #pragma clang diagnostic ignored 用法 UIView常用的setNeedsDisplay和setNeedsLayout]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
</search>
